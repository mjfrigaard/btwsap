---
title: "Structure"
format: 
  html:
    toc: true
    toc-depth: 4
knitr:
  opts_chunk: 
    collapse: true
    comment: "" 

execute:
  echo: true

vignette: >
  %\VignetteIndexEntry{Structure}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| label: setup
#| include: false
library(lobstr)
```

This vignette explains the modules, utility functions, UI and server functions, and standalone app function in the `sap` R package/Shiny application. A folder tree of it's contents is below:

```{r}
library(sap)
```

```{verbatim}
├── DESCRIPTION
├── NAMESPACE
├── R
│   ├── data.R
│   ├── display_type.R
│   ├── dist_var_summary.R
│   ├── get_award_recipients.R
│   ├── launch_app.R
│   ├── logr_msg.R
│   ├── mod_awards_point.R
│   ├── mod_awards_tbl.R
│   ├── mod_awards_vars.R
│   ├── mod_compare_point.R
│   ├── mod_compare_vars.R
│   ├── mod_counts_bar.R
│   ├── mod_counts_tbl.R
│   ├── mod_counts_vars.R
│   ├── mod_counts_vbox.R
│   ├── mod_counts_waffle.R
│   ├── mod_dist_box.R
│   ├── mod_dist_raincloud.R
│   ├── mod_dist_tbl.R
│   ├── mod_dist_vars.R
│   ├── name_case.R
│   ├── nav_server.R
│   └── nav_ui.R
├── README.md
├── app.R
├── data
│   ├── clr_pal.rda
│   ├── clr_pal12.rda
│   ├── clr_pal3.rda
│   └── movies.rda
├── data-raw
│   ├── clr_pal12.R
│   ├── clr_pal3.R
│   ├── movies.R
│   └── movies.RData
├── dev
│   └── config_attachment.yaml
├── inst
│   ├── extdata
│   │   ├── movies.csv
│   │   └── movies.fst
│   └── www
│       ├── bootstrap.png
│       └── shiny.png
├── man
│   ├── display_type.Rd
│   ├── dist_var_summary.Rd
│   ├── get_award_recipients.Rd
│   ├── launch_app.Rd
│   ├── logr_msg.Rd
│   ├── mod_awards_point_server.Rd
│   ├── mod_awards_point_ui.Rd
│   ├── mod_awards_tbl_server.Rd
│   ├── mod_awards_tbl_ui.Rd
│   ├── mod_awards_vars_server.Rd
│   ├── mod_awards_vars_ui.Rd
│   ├── mod_compare_point_server.Rd
│   ├── mod_compare_point_ui.Rd
│   ├── mod_compare_vars_server.Rd
│   ├── mod_compare_vars_ui.Rd
│   ├── mod_counts_bar_server.Rd
│   ├── mod_counts_bar_ui.Rd
│   ├── mod_counts_tbl_server.Rd
│   ├── mod_counts_tbl_ui.Rd
│   ├── mod_counts_vars_server.Rd
│   ├── mod_counts_vars_ui.Rd
│   ├── mod_counts_vbox_server.Rd
│   ├── mod_counts_vbox_ui.Rd
│   ├── mod_counts_waffle_server.Rd
│   ├── mod_counts_waffle_ui.Rd
│   ├── mod_dist_box_server.Rd
│   ├── mod_dist_box_ui.Rd
│   ├── mod_dist_raincloud_server.Rd
│   ├── mod_dist_raincloud_ui.Rd
│   ├── mod_dist_tbl_server.Rd
│   ├── mod_dist_tbl_ui.Rd
│   ├── mod_dist_vars_server.Rd
│   ├── mod_dist_vars_ui.Rd
│   ├── movies.Rd
│   ├── name_case.Rd
│   ├── nav_server.Rd
│   └── nav_ui.Rd
├── sap.Rproj
├── tests
│   ├── testthat
│   │   ├── fixtures
│   │   ├── helper.R
│   │   ├── test-mod_awards_point_server.R
│   │   ├── test-mod_awards_tbl_server.R
│   │   ├── test-mod_awards_vars_server.R
│   │   ├── test-mod_compare_point_server.R
│   │   ├── test-mod_compare_vars_server.R
│   │   ├── test-mod_counts_bar_server.R
│   │   ├── test-mod_counts_tbl_server.R
│   │   ├── test-mod_counts_vars_server.R
│   │   ├── test-mod_counts_vbox_server.R
│   │   ├── test-mod_counts_waffle_server.R
│   │   ├── test-mod_dist_box_server.R
│   │   ├── test-mod_dist_raincloud_server.R
│   │   ├── test-mod_dist_tbl_server.R
│   │   └── test-mod_dist_vars_server.R
│   └── testthat.R
└── vignettes
    ├── graphs.qmd
    ├── modules.qmd
    ├── specs.qmd
    └── tables.qmd
```

## Standalone app function

`launch_app()` is the standalone app function (used to launch the application).

```{r}
#| echo: false
#| eval: true
lobstr::ast(
  launch_app(
    display_type()
  )
)
```

### display_type()

`display_type()` controls where to display the app (if it's in RStudio).

```{r}
#| eval: false
#| code-fold: true 
#| code-summary: 'show/hide display_type()'
display_type <- function(run = "w") {
  if (Sys.getenv("RSTUDIO") == "1") {
    switch(run,
      p = options(shiny.launch.browser = .rs.invokeShinyPaneViewer),
      b = options(shiny.launch.browser = .rs.invokeShinyWindowExternal),
      w = options(shiny.launch.browser = .rs.invokeShinyWindowViewer),
      NULL = options(shiny.launch.browser = NULL))
    environment <- "RStudio"
    shinyViewerType <- getOption('shiny.launch.browser') |> 
                        attributes() |> 
                        unlist() |> 
                        unname()
                      
    cli::cli_alert_info("App running in {environment}")
    cli::cli_alert_info("shinyViewerType set to {shinyViewerType}")
  } else {
    environment <- "RStudio"
    cli::cli_alert_info("App not running in {environment}")
  } 
}
```

### launch_app()

`launch_app()` calls `display_type()`, `nav_ui()` and `nav_server()`:

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide launch_app()'
launch_app <- function(options = list(), run = "p", ...) {
  
  if (interactive()) {
    display_type(run = run)
  }
    
    options(shiny.useragg = TRUE)
    
    logger::log_threshold(level = "INFO")
    
    ggplot2::theme_set(ggplot2::theme_minimal())
    
    thematic::thematic_shiny(
      bg = "#121212",
      fg = "#ffffff",
      accent = "#bdbdbd", 
      font = "auto")
    
    shinyApp(
      ui = nav_ui(...),
      server = nav_server,
      options = options
    )
    
}
```

## UI and Server

```{r}
#| echo: false
#| eval: true
lobstr::ast(
  launch_app(
    display_type(),
    nav_ui(),
    nav_server()
  )
)
```

The `nav_ui()` and `nav_server()` functions are below:

### nav_ui()

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide nav_ui()'
nav_ui <- function() {
  addResourcePath(
    prefix = 'www',
    directoryPath = system.file('www', package = 'sap'))

  tagList(
    tags$style(
      HTML("
      .reactable {
        background-color: #121212;
        color: #ffffff;
      }
      .reactable .rt-tbody .rt-tr-group {
        border-color: #2979ff;
      }
      .reactable .rt-thead .rt-th, .reactable .rt-tbody .rt-td {
        color: #ffffff;
      }
      .reactable .rt-thead .rt-th {
        background-color: #121212;
      }
      .reactable .rt-tbody .rt-td {
        background-color: #121212;
      }
    ")
  ),
    bslib::page_navbar(
      theme = bslib::bs_theme(
        version = 5,
        bg = "#000000",          # pure black background for maximum contrast
        fg = "#ffffff",          # white text color for sharp contrast
        primary = "#2979ff",     # bright blue primary color
        secondary = "#bdbdbd",   # light gray for secondary elements
        body_bg = "#121212",     # dark gray for the main content background
        base_font = sass::font_google("Roboto") # base font from Google
      ),
      title = "Movie Reviews",
      fillable = "Compare",
      bslib::nav_panel(
        "Compare",
        # Compare (nav_ui) ----
        bslib::card(
          full_screen = TRUE,
          bslib::layout_sidebar(
            sidebar = bslib::sidebar(
              class = "p-0",
              ## Scatter inputs (UI) ---- 
              mod_compare_vars_ui("scatter_inputs"),
            ),
            bslib::card_body(
              class = "p-0",
              ## Scatter plot (UI) ----
              mod_compare_point_ui(id = "scatter"),
              bslib::card_footer(
                tags$blockquote(
                  tags$em(
                    tags$p(
                      "The data for this application comes from the ",
                      tags$a("Building web applications with Shiny",
                        href = "https://rstudio-education.github.io/shiny-course/"
                      ),
                      "tutorial"
                    )
                  )
                )
              )
            )
          )
        )
      ),
      bslib::nav_panel(
        # Counts (UI) ----
        "Counts",
        bslib::navset_card_tab(
          height = "800px",
          full_screen = TRUE,
          sidebar =
            bslib::sidebar(
              class = "p-0",
              ## Count Vars (UI) ----
              mod_counts_vars_ui("year")
            ),
          bslib::nav_panel(
            markdown("Graphs"),
            bslib::card_body(
              ### Bars (UI) ----
              mod_counts_bar_ui(id = "hbar"),
              ### Waffle (UI) ----
              mod_counts_waffle_ui(id = "waffle")
            )
          ),
          bslib::nav_panel(
            markdown("Table"),
            bslib::card_header(
              ### Vbox (UI) ----
              mod_counts_vbox_ui("cnt_txt")
            ),
            bslib::card_body(
              ### Counts Table (UI) ----
              mod_counts_tbl_ui(id = "cnt_tbl")
            )
          )
        )
      ),
      bslib::nav_panel(
        "Distributions",
        # Distributions (UI) ----
        bslib::navset_card_tab(
          sidebar =
            bslib::sidebar(
              class = "p-0",
              ## Dist Vars (UI) ----
              mod_dist_vars_ui("dist")
            ),
          bslib::nav_panel(
            markdown("Graphs"),
            bslib::card_body(
              ### Box plot (UI) ----
              mod_dist_box_ui(id = "box"),
              ### Rain Cloud plot (UI) ----
              mod_dist_raincloud_ui(id = "cloud")
            )
          ),
          bslib::nav_panel(
            markdown("Table"),
            ### Distribution table (UI) ----
            mod_dist_tbl_ui("dist_tbl")
          )
        )
      ),
      bslib::nav_panel(
        "Awards",
        # Awards (UI) ----
        bslib::navset_card_tab(
          full_screen = TRUE,
          sidebar =
            bslib::sidebar(
              class = "p-0",
              ## Awards Vars (UI) ----
              mod_awards_vars_ui(id = "awards_vars"),
            ),
          bslib::nav_panel(
            markdown("Graphs"),
            bslib::card_body(
              ### Awards Graph (UI) ----
              mod_awards_point_ui(id = "awards_plot")
            )
          ),
          bslib::nav_panel(
            markdown("Table"),
            bslib::card_body(
              ### Awards Table (UI) ----
              mod_awards_tbl_ui(id = "awards_table")
            )
          )
        )
      )
    )
  )
}
```

### nav_server()

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide nav_server()'
nav_server <- function(input, output) {

  # scatter plot values
  scatter_values <- mod_compare_vars_server("scatter_inputs")
  mod_compare_point_server(id = "scatter", vals = scatter_values)

  # count values
  count_values <- mod_counts_vars_server("year")
  mod_counts_vbox_server("cnt_txt", count_values)
  mod_counts_bar_server(id = "hbar", vals = count_values)
  mod_counts_waffle_server(id = "waffle", vals = count_values)
  mod_counts_tbl_server(id = "cnt_tbl", vals = count_values)

  # distribution values
  dist_values <- mod_dist_vars_server("dist")
  mod_dist_raincloud_server("cloud", vals = dist_values)
  mod_dist_box_server("box", vals = dist_values)
  mod_dist_tbl_server("dist_tbl", vals = dist_values)

  # awards values
  award_values <- mod_awards_vars_server("awards_vars")
  mod_awards_point_server("awards_plot", award_values)
  mod_awards_tbl_server("awards_table", award_values)

}
```

## Application modules

### Utility functions

The following utility functions are used in the application modules:

#### name_case()

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide name_case()'
name_case <- function(x, case = "title") {
  if (!is.character(x)) {
    stop("Input must be a character vector.")
  }

  change_case <- function(name, case) {
    # Split by underscores or non-alphanumeric characters
    sep_words <- strsplit(name, "_|[^[:alnum:]]+")[[1]]

    case_words <- switch(
      case,
      title = paste0(
        toupper(substring(sep_words, 1, 1)),
        tolower(substring(sep_words, 2))
      ),
      lower = tolower(sep_words),
      stop("Unsupported case.")
    )

    if (case == "lower") {
      # Return snake_case
      return(paste(case_words, collapse = "_"))
    } else {
      # Return title case with spaces
      return(paste(case_words, collapse = " "))
    }
  }

  named_vector <- sapply(x, change_case, case)

  return(unname(named_vector))
}
```

#### logr_msg()

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide logr_msg()'
logr_msg <- function(message, level = "INFO", log_file = NULL, json = FALSE) {

  # Set default formatter
  logger::log_formatter(formatter = logger::formatter_glue)

  # Log to console by default
  switch(
    level,
    "FATAL"   = logger::log_fatal("{message}"),
    "ERROR"   = logger::log_error("{message}"),
    "WARN"    = logger::log_warn("{message}"),
    "SUCCESS" = logger::log_success("{message}"),
    "DEBUG"   = logger::log_debug("{message}"),
    "TRACE"   = logger::log_trace("{message}"),
    logger::log_info("{message}")  # Default fallback
  )

  # Log to file only if log_file is specified
  if (!is.null(log_file)) {
    log_dir <- dirname(log_file)

    if (!dir.exists(log_dir)) {
      dir.create(log_dir, recursive = TRUE)
    }

    if (!file.exists(log_file)) {
      file.create(log_file)
    }

    if (json) {
      logger::log_appender(logger::appender_tee(log_file))
      logger::log_layout(logger::layout_json())
    } else {
      logger::log_appender(logger::appender_tee(log_file))
      logger::log_layout(logger::layout_glue_generator())
    }
  }
}
```

## Module files

The module files in the R folder are listed below.

```{r}
#| eval: true
#| echo: false
#| collapse: false
fs::dir_tree("../R", regexp = "mod")
```

## Module structure

The modules are structured into `compare`, `counts`, distribution (`dist`), and `awards`. The modules in the application have the following naming convention:

**`mod_<tab>_<type>_ui/server`**

-   `<tab>` is the name of the tab (**Compare**, **Counts**, **Distributions**, **Awards**)
-   **`<type>`**
    -   `vars`: 'variable' collection modules to return inputs\
    -   `tbl`: table display modules\
    -   type of display in module (i.e., `point`, `bar`, `vbox`, etc.)

Each tab's modules are organized into abstract syntax trees[^1] in the sections below.

[^1]: Create abstract syntax trees with the [`lobstr::ast()` function](https://lobstr.r-lib.org/reference/ast.html).

### Compare

The `mod_compare_*` modules collect the variables for the scatter plot.

```{r}
#| echo: false
#| eval: true
lobstr::ast(
  launch_app(
    display_type(),
    nav_ui(
      mod_compare_vars_ui(
        name_case()
        ),
      mod_compare_point_ui()
    ),
    nav_server(
      mod_compare_vars_server(
        name_case(),
        logr_msg()
      ),
      mod_compare_point_server(
        name_case(),
        logr_msg()
      )
    )
  )
)
```

#### mod_compare_vars

`mod_compare_vars`: collects the inputs.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_compare_vars'
mod_compare_vars_ui <- function(id) {
  num_vars <- movies[c(
    "runtime", "imdb_rating",
    "imdb_num_votes", "critics_score",
    "audience_score"
  )]
  num_nms <- names(num_vars) |> name_case()

  num_data <- setNames(object = num_vars, nm = num_nms)

  chr_vars <- movies[c("mpaa_rating", "genre", "critics_rating")]
  chr_nms <- names(chr_vars) |> name_case()
  chr_data <- setNames(object = chr_vars, nm = chr_nms)

  ns <- NS(id)
  tagList(
    varSelectInput(
      inputId = ns("var_x"),
      label = strong("X variable"),
      data = num_data,
      selected = "Imdb Rating"
    ),
    varSelectInput(
      inputId = ns("var_y"),
      label = strong("Y variable"),
      data = num_data,
      selected = "Audience Score"
    ),
    varSelectInput(
      inputId = ns("color"),
      label = strong("Color by:"),
      data = chr_data,
      selected = "Critics Rating"
    ),
    sliderInput(
      inputId = ns("alpha"),
      label = strong("Alpha"),
      min = 0.5,
      max = 1.0,
      step = 0.1,
      value = 0.7
    ),
    sliderInput(
      inputId = ns("size"),
      label = strong("Size"),
      min = 5,
      max = 10,
      step = 0.5,
      value = 7
    ),
    textInput(
      inputId = ns("plot_title"),
      label = strong("Plot title"),
      placeholder = "Enter plot title"
    )
  )
}
mod_compare_vars_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    logr_msg("Initializing variable comparison module",
      level = "INFO")

    observe({
      logr_msg(glue::glue("X variable changed to: {input$var_x}"),
        level = "DEBUG"
      )

      if (input$var_x == input$var_y) {
        logr_msg("X and Y variables match, updating Y selection",
          level = "WARN")
        num_cols <- name_case(c(
          "audience_score", "critics_score", "imdb_num_votes",
          "imdb_rating", "runtime"
        ), case = "title")
        y_cols <- num_cols[num_cols != input$var_x]

        updateSelectInput(
          session = session,
          inputId = "var_y",
          choices = y_cols,
          selected = y_cols[1]
        )

        logr_msg(glue::glue("Y variable auto-updated to: {y_cols[1]}"),
          level = "INFO"
        )
      }
    }) |>
      bindEvent(input$var_x)

    observe({
      logr_msg(glue::glue("Y variable changed to: {input$var_y}"),
        level = "DEBUG"
      )

      if (input$var_y == input$var_x) {
        logr_msg("Y and X variables match, updating X selection", 
          level = "WARN")
        num_cols <- name_case(c(
          "audience_score", "critics_score",
          "imdb_num_votes", "imdb_rating", "runtime"
        ))
        x_cols <- num_cols[num_cols != input$var_y]

        updateSelectInput(
          session = session,
          inputId = "var_x",
          choices = x_cols,
          selected = x_cols[1]
        )

        logr_msg(glue::glue("X variable auto-updated to: {x_cols[1]}"),
          level = "INFO"
        )
      }
    }) |>
      bindEvent(input$var_y)

    # Return selected variables as reactive list
    logr_msg("Variable comparison module ready",
      level = "TRACE")

    return(
      reactive({
        logr_msg("Variable selections updated",
          level = "DEBUG")
        list(
          "x" = input$var_x,
          "y" = input$var_y,
          "color" = input$color,
          "alpha" = input$alpha,
          "size" = input$size,
          "title" = input$plot_title
        )
      })
    )
  })
}
```

#### mod_compare_point

`mod_compare_point`: displays the graph.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_compare_point'
mod_compare_point_ui <- function(id) {
  ns <- NS(id)
  tagList(
    plotly::plotlyOutput(ns("scatter"),
      width = '100%', height = '100%')
  )
}
mod_compare_point_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    logr_msg("Initializing point comparison module",
      level = "DEBUG")

    label_inputs <- reactive({
      req(vals()$x, vals()$y, vals()$c)

      logr_msg(
        glue::glue(
          "Setting up labels with x={vals()$x}, y={vals()$y},",
          " color={vals()$color}"
        ),
        level = "TRACE"
      )

      list(
        x = name_case(as.character(vals()$x)),
        y = name_case(as.character(vals()$y)),
        color = name_case(as.character(vals()$color)),
        title = name_case(as.character(vals()$title)),
        subtitle = paste(
          name_case(as.character(vals()$x)),
          "vs.", name_case(as.character(vals()$y)),
          "and", name_case(as.character(vals()$c))
        )
      )
    })

    output$scatter <- plotly::renderPlotly({
      req(label_inputs())

      logr_msg("Preparing to render scatter plot",
        level = "DEBUG"
      )

      tryCatch(
        {
          # clean names
          nms <- name_case(names(movies))
          compare_data <- stats::setNames(object = movies, nm = nms)

          logr_msg(glue::glue("Creating plot with {nrow(compare_data)} data points"),
            level = "INFO"
          )

          if (nrow(compare_data) > 5000) {
            logr_msg("Large dataset detected - rendering may be slow",
              level = "WARN"
            )
          }

          plot <- plotly::plot_ly(
            data = compare_data,
            x = ~ get(vals()$x),
            y = ~ get(vals()$y),
            color = ~ get(vals()$color),
            text = ~title,
            type = "scatter",
            mode = "markers",
            colors = clr_pal3,
            marker = list(
              size = vals()$size,
              opacity = vals()$alpha
            )
          ) |>
            plotly::layout(
              title = list(
                text = label_inputs()$title,
                font = list(color = "#e0e0e0")
              ),
              xaxis = list(
                title = label_inputs()$x,
                titlefont = list(color = "#e0e0e0"),
                tickfont = list(color = "#e0e0e0")
              ),
              yaxis = list(
                title = label_inputs()$y,
                titlefont = list(color = "#e0e0e0"),
                tickfont = list(color = "#e0e0e0")
              ),
              legend = list(
                font = list(color = "#e0e0e0")
              ),
              plot_bgcolor = "#121212",
              paper_bgcolor = "#121212"
            )

          logr_msg("Scatter plot rendered successfully",
            level = "DEBUG"
          )
          return(plot)
        },
        error = function(e) {
          logr_msg(glue::glue("Failed to render scatter plot: {e$message}"),
            level = "ERROR"
          )

          # Return minimal error plot
          plotly::plot_ly() |>
            plotly::add_annotations(
              text = "Error rendering plot. Please check your selections.",
              showarrow = FALSE,
              font = list(color = "#e0e0e0")
            ) |>
            plotly::layout(
              plot_bgcolor = "#121212",
              paper_bgcolor = "#121212"
            )
        }
      )
    })

    # log when module is disposed (session ends)
    session$onSessionEnded(function() {
      logr_msg("Point comparison module session ended",
        level = "INFO"
      )
    })
  })
}
```

### Counts

The `mod_counts_*` modules create and display various counts of categorical variables from the `movies` data.

```{r}
#| echo: false
#| eval: true
lobstr::ast(
  launch_app(
    display_type(),
    nav_ui(
      mod_counts_vars_ui(
        name_case()
        ),
      mod_counts_vbox_ui(),
      mod_counts_bar_ui(),
      mod_counts_waffle_ui(),
      mod_counts_tbl_ui()
    ),
    nav_server(
      mod_counts_vars_sever(
        logr_msg()
      ),
      mod_counts_vbox_server(
        logr_msg()
      ),
      mod_counts_bar_server(
        logr_msg(),
        name_case()
      ),
      mod_counts_waffle_server(
        logr_msg(),
        name_case()
      ),
      mod_counts_tbl_server(
        logr_msg(),
        name_case()
      )
    )
  )
)
```

#### mod_counts_vars

`mod_counts_vars_ui`: collects the inputs.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_counts_vars'
mod_counts_vars_ui <- function(id) {
  # define variables 
  chr_vars <- movies[c("genre", "title_type", "mpaa_rating", 
                       "critics_rating", "audience_rating")]
  chr_nms <- names(chr_vars) |> name_case()
  chr_data <- setNames(object = chr_vars, nm = chr_nms)
  
  ns <- NS(id)
    tagList(
        varSelectInput(
          inputId = ns("chr_var"),
          label = strong("Group variable"),
          data = chr_data,
          selected = "Mpaa Rating"
        ),
        markdown("**Theater Release Year**"),
        numericInput(
        inputId = ns("start_year"),
        label = "Start",
        value = 1980,
        min = min(movies[["thtr_rel_year"]]),
        max = max(movies[["thtr_rel_year"]]),
        step = 1
      ),
        numericInput(
        inputId = ns("end_year"),
        label = "End",
        value = 1990,
        min = min(movies[["thtr_rel_year"]]),
        max = max(movies[["thtr_rel_year"]]),
        step = 1
      )
    )
}
mod_counts_vars_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    
    logr_msg(glue::glue("Initializing counts variable module {id}"), 
             level = "DEBUG")
    
    observe({
      if (input$start_year >= input$end_year) {
        logr_msg(glue::glue("Adjusting end_year from {input$end_year} to 
                            {input$start_year + 1} as it was <= start_year"), 
                 level = "DEBUG")
        
        updateNumericInput(
          session = session, 
          inputId = "end_year", 
          value = input$start_year + 1)
      }
    }) |> 
      bindEvent(input$start_year)
    
    observe({
      if (input$end_year <= input$start_year) {
        logr_msg(glue::glue("Adjusting start_year from {input$start_year} to 
                            {input$end_year - 1} as it was >= end_year"), 
                 level = "DEBUG")
        
        updateNumericInput(
          session = session, 
          inputId = "start_year", 
          value = input$end_year - 1)
      }
    }) |> 
      bindEvent(input$end_year)
    
    return(
      reactive({
        valid_years <- req({nchar(input$start_year) == 4 & 
                           nchar(input$end_year) == 4})
        
        if (valid_years) {
          logr_msg(glue::glue("Year range set to {input$start_year}-
                              {input$end_year}, variable: {input$chr_var}"), 
                   level = "INFO")
        } else {
          logr_msg("Invalid year format detected", 
            level = "WARN")
        }
        
        list(
          "start_year" = input$start_year,
          "end_year" = input$end_year,
          "chr_var" = input$chr_var
        )
      })
    )
  })
}
```

#### mod_counts_vbox

`mod_counts_vbox_ui`: displays the value box.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_counts_vbox'
mod_counts_vbox_ui <- function(id) {
  ns <- NS(id)
  tagList(
    bslib::value_box(
      full_screen = FALSE, 
      fill = FALSE,
      title = markdown("#### Totals"), 
      value = textOutput(ns("counts_text")),
      showcase = bsicons::bs_icon("film"),
      h4(
        textOutput(ns("years_text"))
        )
      )
    )
}
mod_counts_vbox_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    
    # Reactive to filter data based on year range
    filtered_data <- reactive({
      req(vals())
      
      logr_msg(
        glue::glue("Filtering movies between {vals()$start_year} and 
        {vals()$end_year}"),
        level = "DEBUG"
      )
      
      subset(movies, 
        thtr_rel_year >= vals()$start_year &
        thtr_rel_year <= vals()$end_year)
      })
      
      # Count of unique movies
      output$counts_text <- renderText({
        logr_msg("Rendering movie count text", level = "TRACE")
        
        tryCatch({
          movie_count <- length(unique(filtered_data()$imdb_url))
          
          logr_msg(
            glue::glue("Found {movie_count} unique movies in selected range"),
            level = "DEBUG"
          )
          
          paste(movie_count, "movies")
        }, error = function(e) {
          logr_msg(
            glue::glue("Error calculating movie count: {e$message}"),
            level = "ERROR"
          )
          "Error calculating movie count"
        })
      })
      
      # Year span text
      output$years_text <- renderText({
        logr_msg("Rendering year span text", 
          level = "TRACE")
        
        tryCatch({
          time_span <- abs(vals()$start_year - vals()$end_year)
          
          logr_msg(
            glue::glue("Calculated time span: {time_span} years"),
            level = "DEBUG"
          )
          
          paste(time_span, "years")
        }, error = function(e) {
          logr_msg(
            glue::glue("Error calculating year span: {e$message}"),
            level = "ERROR"
          )
          "Error calculating year span"
        })
      })
    })
}
```

#### mod_counts_bar

`mod_counts_bar_ui`: displays the bar plot.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_counts_bar'
mod_counts_bar_ui <- function(id) {
  ns <- NS(id)
  tagList(
    plotOutput(outputId = ns("hbar_graph"))
  )
}
mod_counts_bar_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    logr_msg("Initializing horizontal bar plot module",
      level = "INFO"
    )

    output$hbar_graph <- renderPlot({
      logr_msg("Attempting to render horizontal bar plot",
        level = "TRACE"
      )

      # Validate input values
      req(vals())

      tryCatch(
        {
          # Prepare data for plotting
          logr_msg(glue::glue("Filtering data from {vals()$start_year} to
        {vals()$end_year}"),
            level = "DEBUG"
          )

          x_lab <- name_case(as.character(vals()$chr_var))

          counts_data <- subset(
            movies,
            thtr_rel_year >= vals()$start_year &
              thtr_rel_year <= vals()$end_year
          )

          if (nrow(counts_data) == 0) {
            logr_msg("No data available after filtering by year range",
              level = "WARN"
            )
            return(NULL)
          }

          logr_msg(glue::glue("Creating bar plot with {vals()$chr_var} variable"),
            level = "DEBUG"
          )

          counts_nms <- names(counts_data) |> name_case()
          counts_data <- setNames(
            object = counts_data,
            nm = counts_nms
          )

          # Create plot
          ggplot2::ggplot(
            counts_data,
            ggplot2::aes(
              x =
                forcats::fct_rev(
                  forcats::fct_infreq(
                    !!vals()$chr_var
                  )
                )
            )
          ) +
            ggplot2::geom_bar(
              ggplot2::aes(
                fill = !!vals()$chr_var
              ),
              show.legend = FALSE
            ) +
            ggplot2::coord_flip() +
            ggplot2::scale_fill_manual(values = clr_pal12) +
            ggplot2::labs(
              x = NULL,
              y = "# of Movies",
              fill = x_lab
            ) +
            ggplot2::theme(
              legend.position = "none",
              axis.text = ggplot2::element_text(color = "#ffffff", size = 14),
              axis.title = ggplot2::element_text(color = "#ffffff", size = 16)
            )
        },
        error = function(e) {
          logr_msg(glue::glue("Error rendering bar plot: {e$message}"),
            level = "ERROR"
          )
          NULL
        }
      )
    })

    logr_msg("Horizontal bar plot module initialized",
      level = "INFO"
    )
  })
}
```

#### mod_counts_waffle

`mod_counts_waffle_ui`: displays the waffle chart.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_counts_waffle'
mod_counts_waffle_ui <- function(id) {
  ns <- NS(id)
    tagList(
      plotOutput(outputId = ns("waffle_plot"))
    )
}
mod_counts_waffle_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    
    output$waffle_plot <- renderPlot({
      logr_msg("Starting waffle plot rendering", 
        level = "TRACE")
      
      req(vals())
      
      tryCatch({
        # Get parameters from inputs
        x_lab <- name_case(as.character(vals()$chr_var))
        movies <- sap::movies
        
        logr_msg(glue::glue("Filtering data from {vals()$start_year} to 
        {vals()$end_year}"),
          level = "DEBUG")
        
        # Subset data based on year range
        waffle_set <- subset(movies, 
          thtr_rel_year >= vals()$start_year &
          thtr_rel_year <= vals()$end_year)
          
          if (nrow(waffle_set) == 0) {
            logr_msg("No data available for selected year range", 
              level = "WARN")
          }
          
          # Clean names 
          nms_set <- names(waffle_set) |> name_case()
          movie_vars <- setNames(object = waffle_set, nm = nms_set)
          movie_vars$chr_var <- as.character(movie_vars[[vals()$chr_var]])
          
          logr_msg(glue::glue("Creating waffle plot for {vals()$chr_var}"), 
          level = "DEBUG")
          
          # Create waffle iron data structure
          movies_iron <- ggwaffle::waffle_iron(movie_vars,
            ggwaffle::aes_d(group = chr_var))
            
            # Build plot
            ggplot2::ggplot(data = movies_iron, 
              ggplot2::aes(x = x, 
                y = y, 
                fill = group)) + 
                ggwaffle::geom_waffle() +
                ggplot2::scale_fill_manual(values = clr_pal12) +  
                ggplot2::labs(
                  x = "", y = "", 
                  fill = x_lab
                ) + 
                ggwaffle::theme_waffle() +
                ggplot2::theme( 
                  legend.text = ggplot2::element_text(
                    color = "#ffffff", size = 14),
                  legend.title = ggplot2::element_text(
                    color = "#ffffff", size = 16)
                )
                
              }, error = function(e) {
                logr_msg(glue::glue("Failed to render waffle plot: {e$message}"), 
                level = "ERROR")
                
                # Return an empty plot with error message
                ggplot2::ggplot() + 
                ggplot2::annotate("text", x = 0, y = 0, 
                label = "Error creating waffle plot") +
                ggplot2::theme_minimal()
            })
        })
    })
}
```

#### mod_counts_tbl

`mod_counts_tbl_ui`: displays the counts table.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_counts_tbl'
mod_counts_tbl_ui <- function(id) {
  ns <- NS(id)
  tagList(
    gt::gt_output(
      outputId = ns("counts_table")
    )
  )
}
mod_counts_tbl_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    
    output$counts_table <- gt::render_gt({
      req(vals())
      # subset
      count_data <- subset(
        movies,
        thtr_rel_year >= vals()$start_year &
        thtr_rel_year <= vals()$end_year
      )

      # convert selected variable to snake_case
      group_var <- name_case(as.character(vals()$chr_var), case = "lower")

      # count per group using tidy evaluation
      tbl_data <- count_data |>
        dplyr::group_by(.data[[group_var]]) |>
        dplyr::summarise(n = dplyr::n(), .groups = "drop") |>
        dplyr::arrange(dplyr::desc(n))
      
      # normalize column names in the data
      names(tbl_data) <- name_case(names(tbl_data))
      
      # gt table with dark theme styling
      gt::gt(tbl_data) |> 
      gt::tab_options(
        table.width = gt::pct(100),
        table.font.color = "#ffffff",
        table.align = "left",
        heading.align = "left",
        table.background.color = "#121212",
        column_labels.background.color = "#1e1e1e",
        table.font.size = gt::px(20),
        table.border.top.style = "hidden",
        table.border.bottom.style = "hidden"
      ) |> 
      gt::opt_row_striping()
    })
    
  })
}
```

### Distributions

The **Distributions** tab displays two graphs and a table of summary statistics.

```{r}
#| echo: false
#| eval: true
lobstr::ast(
  launch_app(
    display_type(),
    nav_ui(
      mod_dist_vars_ui(
        name_case()
      ),
      mod_dist_box_ui(),
      mod_dist_raincloud_ui(),
      mod_dist_tbl_ui()
    ),
    nav_server(
      mod_dist_vars_server(
        logr_msg()
      ),
      mod_dist_box_server(
        logr_msg(),
        name_case()
      ),
      mod_dist_raincloud_server(
        logr_msg(),
        name_case()
      ),
      mod_dist_tbl_server(
        logr_msg(),
        name_case(),
        dist_var_summary()
      )
    )
  )
)
```

#### dist_var_summary()

The `dist_var_summary()` returns the summary statistics from the **Distributions** tab.

```{r}
#| eval: false 
#| code-fold: true
#| code-summary: 'show/hide dist_var_summary()'
dist_var_summary <- function(data, grp_var, num_var) {
  
  if (!is.data.frame(data)) {
    stop("The input 'data' must be a data frame.")
  }
  # check character strings
  if (!is.character(grp_var) || length(grp_var) != 1) {
    stop("The input 'grp_var' must be a single character string.")
  }
  if (!is.character(num_var) || length(num_var) != 1) {
    stop("The input 'num_var' must be a single character string.")
  }
  # check in the data frame
  if (!(grp_var %in% names(data))) {
    stop(paste("The character variable", grp_var, "does not exist in the data frame."))
  }
  if (!(num_var %in% names(data))) {
    stop(paste("The numeric variable", num_var, "does not exist in the data frame."))
  }
  # check if character or factor
  if (!is.character(data[[grp_var]]) && !is.factor(data[[grp_var]])) {
    stop(paste("The variable", grp_var, "must be of type character or factor."))
  }
  # check if numeric
  if (!is.numeric(data[[num_var]])) {
    stop(paste("The variable", num_var, "must be of type numeric."))
  }
  unique_groups <- unique(data[[grp_var]])
  result <- do.call(rbind, lapply(unique_groups, function(group) {
    subset_data <- data[data[[grp_var]] == group, ]
    n <- nrow(subset_data)
    Mean <- round(mean(subset_data[[num_var]], na.rm = TRUE), 2)
    SD <- round(sd(subset_data[[num_var]], na.rm = TRUE), 2)
    Min <- min(subset_data[[num_var]], na.rm = TRUE)
    Max <- max(subset_data[[num_var]], na.rm = TRUE)
    IQR_value <- round(IQR(subset_data[[num_var]], na.rm = TRUE), 2)
    data.frame(group = group, 
      n = n, Mean = Mean, SD = SD, 
      Min = Min, Max = Max, 
      IQR = IQR_value)
  }))
  rownames(result) <- NULL
  tbl_names <- name_case(names(result))
  tbl <- stats::setNames(object = result, nm = tbl_names)
  return(tbl)
}
```

```{r}
#| comment: "# "
df <- data.frame(
  group = c("A", "B", "A", "B"), 
  value = c(10, 20, 30, 40))
dist_var_summary(df, "group", "value")
```

```{r}
#| comment: "# "
dist_var_summary(movies, 'mpaa_rating', 'runtime')
```

#### mod_dist_vars

`mod_dist_vars_ui`: collects the inputs.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_dist_vars'
mod_dist_vars_ui <- function(id) {
  num_data <- movies[c("critics_score", "audience_score", "runtime", 
                       "imdb_rating")]
  num_nms <- names(num_data) |> name_case()
  num_data <- setNames(num_data, num_nms)
  
  rating_data <- movies[c("critics_rating", "audience_rating")]
  rating_nms <- names(rating_data) |> name_case()
  rating_data <- setNames(rating_data, rating_nms)

  ns <- NS(id)
  tagList(
    varSelectInput(
      inputId = ns("chr_var"),
      label = a(strong("Y (Color/group variable)")),
      data = rating_data,
      selected = "Critics Rating"
    ),
    varSelectInput(
      inputId = ns("num_var"),
      label = a(strong("X (Numeric variable)")),
      data = num_data,
      selected = "Audience Score"
    ),
    markdown("**Customize**"),
    sliderInput(
      inputId = ns("alpha"),
      label = "Alpha",
      min = 0.2, 
      max = 1.0, 
      step = 0.2,
      value = 0.8
    ),
    sliderInput(
      inputId = ns("size"),
      label = "Size/scale",
      min = 1, 
      max = 5,
      step = 0.5,
      value = 3.0
    )
  )
}
mod_dist_vars_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    
    logr_msg("Initializing distribution variables module", 
      level = "DEBUG")
    
    # create reactive to track selected variables
    selected_vars <- reactive({
      logr_msg(glue::glue("Variables updated: num={input$num_var}, 
      chr={input$chr_var}"), 
        level = "TRACE")
      
      if (is.null(input$num_var) || is.null(input$chr_var)) {
        logr_msg("Missing required variable selections", 
          level = "WARN")
      }
      
      list(
        "num_var" = input$num_var,
        "chr_var" = input$chr_var,
        "alpha" = input$alpha,
        "size" = input$size
      )
    })
    
    logr_msg("Distribution variables module initialized", 
      level = "DEBUG")
    
    return(selected_vars)
  })
}
```

#### mod_dist_box

`mod_dist_box_ui`: displays the box plot.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_dist_box'
mod_dist_box_ui <- function(id) {
  ns <- NS(id)
  tagList(
    plotOutput(outputId = ns("box"))
  )
}
mod_dist_box_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    output$box <- renderPlot(
      {
        req(vals())

        logr_msg("Preparing box plot in mod_dist_box_server", 
          level = "TRACE")

        tryCatch(
          {
            # pretty names
            mv_nms <- names(sap::movies) |> name_case()
            movie_data <- setNames(object = sap::movies, nm = mv_nms)

            logr_msg(glue::glue("Processing data with {nrow(movie_data)} rows"),
              level = "DEBUG"
            )

            d_bp <- subset(
              movie_data,
              !is.na(as.character(vals()$num_var)) &
                !is.na(as.character(vals()$chr_var))
            )

            # log warning if significant data filtering occurred
            if (nrow(d_bp) < nrow(movie_data) * 0.7) {
              logr_msg(glue::glue("Significant data loss: {nrow(movie_data) -
                          nrow(d_bp)} rows removed due to NA values"), 
                level = "WARN")
            }

            a <- as.numeric(vals()$alpha)
            s <- as.numeric(vals()$size)

            logr_msg(glue::glue("Creating box plot with {vals()$num_var} and
                        {vals()$chr_var}"), 
                     level = "DEBUG")

            ggplot2::ggplot(
              d_bp,
              ggplot2::aes(
                x = !!vals()$num_var,
                y = !!vals()$chr_var,
                fill = !!vals()$chr_var
              )
            ) +
              ggplot2::geom_boxplot(
                outlier.size = 2.75,
                alpha = a,
                width = s / 5,
                show.legend = FALSE
              ) +
              ggplot2::scale_fill_manual(values = clr_pal12) +
              ggplot2::labs(
                x = name_case(as.character(vals()$num_var)),
                y = name_case(as.character(vals()$chr_var))
              ) +
              ggplot2::theme(
                legend.position = "none",
                strip.text = ggplot2::element_text(
                  color = "#ffffff", 
                  size = ggplot2::rel(1.05)
                ),
                axis.text = ggplot2::element_text(
                  color = "#ffffff", 
                  size = ggplot2::rel(1.075)
                ),
                axis.title = ggplot2::element_text(
                  color = "#ffffff", 
                  size = ggplot2::rel(1.15)
                ),
                plot.background = ggplot2::element_rect(
                  fill = "transparent",
                  color = NA
                )
              )
          },
          error = function(e) {
            logr_msg(glue::glue("Failed to render box plot: {e$message}"),
              level = "ERROR"
            )
            # return a blank plot with error message
            ggplot2::ggplot() +
              ggplot2::annotate("text",
                x = 0, y = 0,
                label = "Error rendering plot",
                color = "red", size = 6
              ) +
              ggplot2::theme_void()
          }
        )
      },
      res = 96
    )
  })
}
```

#### mod_dist_raincloud

`mod_dist_raincloud_ui`: displays the raincloud plot.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_dist_raincloud'
mod_dist_raincloud_ui <- function(id) {
  ns <- NS(id)
  tagList(
    plotOutput(outputId = ns("cloud"))
  )
}
mod_dist_raincloud_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    output$cloud <- renderPlot(
      {
        req(vals())

        logr_msg("Starting raincloud plot generation", 
          level = "TRACE")

        tryCatch(
          {
            # pretty names
            logr_msg("Formatting movie data column names", 
              level = "DEBUG")
            mv_nms <- names(sap::movies) |> name_case()
            movie_data <- setNames(object = sap::movies, nm = mv_nms)

            a <- as.numeric(vals()$alpha)
            s <- as.numeric(vals()$size)

            logr_msg(glue::glue("Using alpha={a}, size={s} for plot elements"),
              level = "DEBUG"
            )

            # create boxplot layer
            logr_msg("Creating boxplot base layer", 
              level = "DEBUG")
            gg2_box <- ggplot2::ggplot(
              movie_data,
              ggplot2::aes(x = !!vals()$num_var, y = !!vals()$chr_var)
            ) +
              ggplot2::geom_boxplot(
                ggplot2::aes(fill = !!vals()$chr_var),
                width = 0.10,
                outlier.shape = NA,
                alpha = a,
                show.legend = FALSE
              ) +
              ggplot2::scale_fill_manual(values = clr_pal12)

            # add halfeye layer
            logr_msg("Adding halfeye density layer", 
              level = "DEBUG")
            gg2_halfeye <- gg2_box +
              ggdist::stat_halfeye(
                ggplot2::aes(fill = !!vals()$chr_var),
                alpha = a,
                adjust = s / 5,
                .width = 0,
                point_colour = NA,
                orientation = "horizontal",
                height = 0.75,
                justification = -0.20,
                show.legend = FALSE
              )

            # add points layer
            logr_msg("Adding jittered points layer", 
              level = "DEBUG")
            gg2_point <- gg2_halfeye +
              ggplot2::geom_point(
                ggplot2::aes(fill = !!vals()$chr_var),
                position = ggplot2::position_jitter(
                  seed = 54321,
                  height = .05
                ),
                shape = 21,
                color = "#ffffff",
                alpha = a,
                size = 3,
                show.legend = FALSE
              )

            # final plot with formatting
            logr_msg("Applying final formatting to raincloud plot", 
              level = "DEBUG")
            final_plot <- gg2_point +
              ggplot2::labs(
                x = name_case(as.character(vals()$num_var)),
                y = name_case(as.character(vals()$chr_var))
              ) +
              ggplot2::theme(
                legend.position = "none",
                strip.text = ggplot2::element_text(
                  color = "#ffffff", 
                  size = ggplot2::rel(1.05)
                ),
                axis.text = ggplot2::element_text(
                  color = "#ffffff", 
                  size = ggplot2::rel(1.075)
                ),
                axis.title = ggplot2::element_text(
                  color = "#ffffff", 
                  size = ggplot2::rel(1.15)
                )
              )
            logr_msg("Raincloud plot generation complete", 
              level = "INFO")
            return(final_plot)
          },
          error = function(e) {
            logr_msg(glue::glue("Failed to generate raincloud plot: {e$message}"),
              level = "ERROR"
            )

            # return empty plot with error message
            ggplot2::ggplot() +
              ggplot2::annotate("text",
                x = 0, y = 0,
                label = "Error generating plot"
              ) +
              ggplot2::theme_void()
          }
        )
      },
      res = 96
    )
  })
}
```

#### mod_dist_tbl

`mod_dist_tbl_ui`: display the summary statistics table.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_dist_tbl'
mod_dist_tbl_ui <- function(id) {
  ns <- NS(id)
  tagList(
    gt::gt_output(
      outputId = ns("dist_table")
    )
  )
}
mod_dist_tbl_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    
    output$dist_table <- gt::render_gt({
      logr_msg("Preparing distribution table in mod_dist_tbl_server",
      level = "TRACE")
      
      req(vals())
      
      tryCatch({
        # capture variables from reactive input
        chr_var <- as.character(vals()$chr_var)
        num_var <- as.character(vals()$num_var)
        
        logr_msg(glue::glue("Building table with character var: {chr_var} and 
        numeric var: {num_var}"), 
          level = "DEBUG")
        
        # transform movie data names
        mv_nms <- names(sap::movies) |> name_case()
        movie_data <- setNames(object = sap::movies, nm = mv_nms)
        
        # generate summary data
        tbl_data <- dist_var_summary(data = movie_data, chr_var, num_var)
        
        logr_msg(glue::glue("Generated summary table with {nrow(tbl_data)} rows"),
        level = "INFO")
        
        # create gt table
        tbl_data |>
        gt::gt() |>
        gt::tab_options(
          table.width = gt::pct(100),
          table.background.color = "#121212",
          table.font.color = "#ffffff",
          table.border.top.style = "none",
          table.border.bottom.style = "none",
          table.font.size = gt::px(20)
        ) |>
        gt::opt_row_striping()
        
      }, error = function(e) {
        logr_msg(glue::glue("Failed to generate distribution table. 
        Error: {e$message}"), 
          level = "ERROR")
        
        # return empty data frame with message if there's an error
        data.frame(Error = "Failed to generate table. Please try again.") |>
          gt::gt()
      })
    })
  })
}
```

### Awards

The **Awards** tab display a graph of award-winning movies (with labels for their actors and director).

```{r}
#| echo: false
#| eval: true
lobstr::ast(
  launch_app(
    display_type(),
    nav_ui(
      mod_awards_vars_ui(),
      mod_awards_point_ui(),
      mod_awards_tbl_ui()
    ),
    nav_server(
      mod_awards_vars_server(
        logr_msg()
      ),
      mod_awards_point_server(
        get_award_recipients(),
        logr_msg()
      ),
      mod_awards_tbl_server(
        get_award_recipients(),
        logr_msg(),
        name_case()
      )
    )
  )
)
```

The **Awards** tab uses a special `data.frame` created with the `get_award_recipients()` function.

#### get_award_recipients()

`get_award_recipients()` creates a `data.frame` of only movies that won awards.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide get_award_recipients()'
get_award_recipients <- function(data, award, year) {
  
  if (!award %in% c("picture/director", "actor/actress")) {
    stop("`award` must be either 'picture/director' or 'actor/actress'")
  }

  if (award == "picture/director") {
    start_year <- year - 2
    end_year <- year + 2
    dplyr::filter(
      data,
      .data$best_pic_win == "yes" | .data$best_dir_win == "yes"
    ) |>
      dplyr::filter(
        .data$thtr_rel_year >= start_year,
        .data$thtr_rel_year <= end_year
      ) |>
      dplyr::mutate(
        genre = paste0("(", .data$genre, ")")
      ) |> 
      tidyr::unite(
        col = 'dir_genre',
        c("director", "genre"),
        sep = "\n"
      ) |>
      dplyr::select(
        title = .data$title,
        release_year = .data$thtr_rel_year,
        director_genre = .data$dir_genre
      ) |>
      dplyr::arrange(.data$release_year)

  } else if (award == "actor/actress") {
    start_year <- year - 1
    end_year <- year + 1
    dplyr::filter(
      data,
      .data$best_actor_win == "yes" | .data$best_actress_win == "yes"
    ) |>
      dplyr::filter(
        .data$thtr_rel_year >= start_year,
        .data$thtr_rel_year <= end_year
      ) |>
      tidyr::unite(
        col = 'star',
        c("actor1", "actor2"),
        sep = " &\n"
      ) |>
      dplyr::select(
        title = .data$title,
        release_year = .data$thtr_rel_year,
        star = .data$star
      ) |>
      dplyr::arrange(.data$release_year)
  }
}
```

```{r}
#| comment: "# "
get_award_recipients(
  data = movies, 
  award = "actor/actress", 
  year = 1980)
```

#### mod_awards_vars

`mod_awards_vars`: collects the inputs.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_awards_vars'
mod_awards_vars_ui <- function(id) {
  ns <- NS(id)
  tagList(
    markdown("**Award Type**"),
    selectInput(
      inputId = ns("award"),
      label = "Award Type",
      choices = c("actor/actress", "picture/director"),
      selected = "actor/actress"
    ),
    markdown("**Theater Release Year**"),
    sliderInput(
      inputId = ns("year"),
      label = "Select Year",
      min = 1970,
      max = 2014,
      value = 1987,
      step = 1, 
      sep = ""
    ),
    textOutput(ns("year_label"))
  )
}
mod_awards_vars_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    initialized <- reactiveVal(FALSE)

    logr_msg("Initializing awards variables module", 
      level = "INFO")

    # label for selected range
    output$year_label <- renderText({
      req(input$year_range)
      h4(glue::glue("{input$year} Selected"))
    })

    # log changes
    observe({
      if (initialized()) {
        logr_msg(glue::glue(
          "Awards criteria updated: {input$award}, year {input$year}"
        ), level = "INFO")
      } else {
        initialized(TRUE)
      }
    }) |> bindEvent(input$award, input$year)

    # returned values 
    return(
      reactive({
        req(input$award, input$year)

        list(
          award = input$award,
          year = input$year
        )
      })
    )
  })
}
```

#### mod_awards_point

`mod_awards_point`: displays the scatter plot.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_awards_point'
mod_awards_point_ui <- function(id) {
  ns <- NS(id)
  tagList(
      plotOutput(ns("text_scatter"),
        width = '100%', height = '70vh')
    )
}
mod_awards_point_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {

    output$text_scatter <- shiny::renderPlot({
      shiny::req(vals())

      logr_msg("Creating awards plot with received input values",
        level = "DEBUG")

      tryCatch({
        award <- as.character(vals()$award)
        year <- as.numeric(vals()$year)

        logr_msg(glue::glue("Award: {award}, Year: {year}"),
          level = "DEBUG")

        awards <- get_award_recipients(sap::movies, award, year)
        logr_msg(glue::glue("Created awards dataset with {nrow(awards)} rows"),
          level = "INFO")

        # define year range and award type
        if (award == "picture/director") {
          start_year <- year - 2
          end_year <- year + 2
          label_col <- "director_genre"
        } else {
          start_year <- year - 1
          end_year <- year + 1
          label_col <- "star"
        }

        # jitter points
        pos <- ggplot2::position_jitter(width = 1/100, height = 1/100, seed = 2)

        # create scatter plot
        p <- ggplot2::ggplot(data = awards) +
          ggplot2::aes(
            x = .data$release_year, 
            y = .data$title
            ) +
          ggplot2::geom_point(
            ggplot2::aes(
              color = .data$title
              ),
            position = pos,
            alpha = 1/3,
            size = 1.5,
            show.legend = FALSE
          ) +
          ggplot2::scale_x_continuous(
            breaks = as.integer(
              start_year:end_year
              ),
            labels = scales::label_number(accuracy = 1)
          ) +
          ggplot2::coord_cartesian(clip = "off") +
          ggrepel::geom_label_repel(
            mapping = ggplot2::aes(
              label = .data[[label_col]], 
              fill = .data[[label_col]]),
                color = "#FFFFFF",
                max.iter = 1e5,
                max.time = 1,
                point.padding = 0.5,
                arrow = grid::arrow(
                  length = grid::unit(0.05, "npc"), 
                  type = "closed", 
                  ends = "last"),
                max.overlaps = 35,
                box.padding = 0.60,
                min.segment.length = 3,
                size = 5,
                xlim = c(NA, NA),
                ylim = c(-Inf, Inf),
                show.legend = FALSE
              ) +
          ggplot2::labs(
            x = "Year",
            y = "Awarded Films"
          ) +
          ggplot2::theme(
            legend.position = "none",
            axis.text = ggplot2::element_text(
              color = "#ffffff", size = 14
              ),
            axis.title = ggplot2::element_text(
              color = "#ffffff", size = 16
              )
          )

        logr_msg("Award scatter plot successfully created",
          level = "TRACE")

        print(p)
      }, error = function(e) {
        logr_msg(glue::glue("Error creating award plot: {e$message}"), 
          level = "ERROR")
      })
    })
  })
}
```

#### mod_awards_tbl

`mod_awards_tbl`: displays the awards data in a `gt` table.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'show/hide mod_awards_tbl'
mod_awards_tbl_ui <- function(id) {
  ns <- NS(id)
    tagList(
      gt::gt_output(
        outputId = ns("awards_table"))
    )
}
mod_awards_tbl_server <- function(id, vals) {
  moduleServer(id, function(input, output, session) {
    
    output$awards_table <- gt::render_gt({
      # validate input values
      req(vals())
      
      logr_msg("Preparing awards table with selected parameters", 
        level = "DEBUG")
      logr_msg(glue::glue("Award: {vals()$award}, Year: {vals()$year}"),
        level = "TRACE")
      
      tryCatch({
        # create awards data 
        award <- as.character(vals()$award)
        year <- as.numeric(vals()$year)
        if (award == "picture/director") {
          awards <- get_award_recipients(sap::movies, 
                                         award = "picture/director", 
                                         year = year)
        } else {
          awards <- get_award_recipients(sap::movies, 
                                         award = "actor/actress", 
                                         year = year)
        }
        # normalize columns
        tbl_names <- name_case(names(awards))
        tbl_data <- stats::setNames(object = awards, nm = tbl_names)
        
        logr_msg(glue::glue("Generated awards table with {nrow(tbl_data)} rows"), 
        level = "INFO")
        
        # gt table
        tbl_data |> 
        gt::gt() |>
        gt::tab_options(
          table.width = gt::pct(100),
          table.background.color = "#121212",
          table.font.color = "#ffffff",
          table.border.top.style = "none",
          table.border.bottom.style = "none",
          table.font.size = gt::px(20)
        ) |>
        gt::opt_row_striping()
        
      }, error = function(e) {
        
        logr_msg(glue::glue("Failed to generate distribution table. 
        Error: {e$message}"), 
          level = "ERROR")
        
        # return empty data with message if error
        gt::gt(
          data.frame(
            Error = "Failed to generate table. Please try again.")
          )
        
      })
    })
  })
}
```

## Report 

The sections below outline the prompts submitted to the `gander` addin to include a downloadable report.

### Prompt 1 

> *Prompt: Given the application structure explained in the vignette, add a download report module.*
